from no_element import NoElement


class CircularLinkedList:
    """A circularly linked list."""

    class Node:
        def __init__(self, item, nxt=None):
            self.item = item
            self.next = nxt

    def __init__(self):
        self._tail = None
        self._size = 0

    def size(self):
        return self._size

    def is_empty(self):
        return self._size == 0

    def first(self):
        if self.is_empty():
            return None
        return self._tail.next.item

    def last(self):
        if self.is_empty():
            return None
        return self._tail.item

    def add_first(self, item):
        if self.is_empty():
            self._tail = self.Node(item)
            self._tail.next = self._tail
        else:
            self._tail.next = self.Node(item, self._tail.next)
        self._size += 1

    def add_last(self, item):
        self.add_first(item)
        self._tail = self._tail.next

    def remove_first(self):
        if self.is_empty():
            raise NoElement
        head = self._tail.next
        if head is self._tail:
            # only one element
            self._tail = None
        else:
            self._tail.next = head.next
        self._size -= 1

    def remove_last(self):
        if self.is_empty():
            raise NoElement
        head = self._tail.next
        if head is self._tail:
            # only one element
            self._tail = None
        else:
            # find the second to the last
            while head.next is not self._tail:
                head = head.next
            head.next = self._tail.next
            self._tail = head
        self._size -= 1

    def rotate(self):
        if not self.is_empty():
            self._tail = self._tail.next

    def __iter__(self):
        return self.LinkedIterator(self._tail, self._size)

    class LinkedIterator:
        def __init__(self, tail, size):
            self.i = 0
            self.size = size
            if size > 0:
                self.node = tail.next
            else:
                self.node = None

        def __next__(self):
            if self.i >= self.size:
                raise StopIteration
            answer = self.node.item
            self.node = self.node.next
            self.i += 1
            return answer
from no_element import NoElement

class CircularLinkedList:
    """
    循环链表类
    特点：尾节点的next指针指向头节点，形成闭合循环
    核心属性：_tail（尾节点引用）、_size（链表元素个数）
    """

    class Node:
        """循环链表的节点内部类"""
        def __init__(self, item, nxt=None):
            self.item = item  # 存储节点的数据元素
            self.next = nxt  # 指向下一个节点的引用

    def __init__(self):
        self._tail = None  # 初始化尾节点为None（空链表）
        self._size = 0     # 初始化链表长度为0

    def size(self):
        """获取链表的元素个数"""
        return self._size

    def is_empty(self):
        """判断链表是否为空"""
        return self._size == 0

    def first(self):
        """获取链表的第一个元素（头节点数据）"""
        if self.is_empty():
            return None  # 空链表返回None
        # 尾节点的next指向头节点，直接获取头节点的item
        return self._tail.next.item

    def last(self):
        """获取链表的最后一个元素（尾节点数据）"""
        if self.is_empty():
            return None  # 空链表返回None
        return self._tail.item  # 直接返回尾节点的item

    def add_first(self, item):
        """在链表头部添加元素"""
        if self.is_empty():
            # 空链表时，新节点既是头也是尾，next指向自身
            self._tail = self.Node(item)
            self._tail.next = self._tail
        else:
            # 非空链表，新节点插入到尾节点和原头节点之间
            # 新节点的next指向原头节点（self._tail.next）
            self._tail.next = self.Node(item, self._tail.next)
        self._size += 1  # 链表长度加1

    def add_last(self, item):
        """在链表尾部添加元素"""
        # 复用add_first方法：先在头部添加元素
        self.add_first(item)
        # 尾节点向后移动一位（新添加的元素成为新尾节点）
        self._tail = self._tail.next

    def remove_first(self):
        """删除并返回链表的第一个元素（头节点）"""
        if self.is_empty():
            raise NoElement  # 空链表删除时抛出异常
        head = self._tail.next  # 获取头节点（尾节点的next）
        if head is self._tail:
            # 链表只有一个元素时，删除后尾节点置为None
            self._tail = None
        else:
            # 多个元素时，尾节点的next跳过原头节点，指向原头节点的next
            self._tail.next = head.next
        self._size -= 1  # 链表长度减1
        return head.item  # 返回被删除节点的数据

    def remove_last(self):
        """删除并返回链表的最后一个元素（尾节点）"""
        if self.is_empty():
            raise NoElement  # 空链表删除时抛出异常
        head = self._tail.next  # 获取头节点
        if head is self._tail:
            # 链表只有一个元素时，删除后尾节点置为None
            self._tail = None
        else:
            # 多个元素时，找到倒数第二个节点（尾节点的前驱）
            while head.next is not self._tail:
                head = head.next  # 遍历直到找到尾节点的前驱
            # 前驱节点的next指向头节点，断开与原尾节点的连接
            head.next = self._tail.next
            self._tail = head  # 前驱节点成为新的尾节点
        self._size -= 1  # 链表长度减1
        return self._tail.item  # 返回被删除节点的数据

    def rotate(self):
        """旋转链表：头节点变为尾节点，原第二个节点成为新头节点"""
        if not self.is_empty():
            # 尾节点向后移动一位（原头节点成为新尾节点）
            self._tail = self._tail.next

    def __iter__(self):
        """实现迭代器协议，支持for循环遍历"""
        # 返回自定义的迭代器对象，传入尾节点和链表长度
        return self.LinkedIterator(self._tail, self._size)

    class LinkedIterator:
        """循环链表的迭代器内部类"""
        def __init__(self, tail, size):
            self.i = 0  # 迭代计数器，记录已遍历的元素个数
            self.size = size  # 链表总长度（迭代终止条件）
            if size > 0:
                self.node = tail.next  # 迭代起始节点：头节点（尾节点的next）
            else:
                self.node = None  # 空链表时迭代节点为None

        def __next__(self):
            """迭代器的next方法，返回下一个元素"""
            if self.i >= self.size:
                raise StopIteration  # 遍历完成，抛出停止迭代异常
            answer = self.node.item  # 保存当前节点的数据
            self.node = self.node.next  # 移动到下一个节点
            self.i += 1  # 计数器加1
            return answer  # 返回当前节点的数据
