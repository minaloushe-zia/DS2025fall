顺序表：
遍历与查找：
# 查找元素
for i in range(len(lst)):
    if lst[i] == target:
        return i  # 或进行其他操作

# 使用enumerate同时获取索引和值
for index, value in enumerate(lst):
    if value == target:
        return index
插入与删除：
# 在位置i插入
lst.insert(i, value)

# 删除第一个匹配项
lst.remove(value)

# 删除位置i的元素
del lst[i]
# 或
popped_value = lst.pop(i)
边界情况处理：
# 空列表检查
if not lst:  # 或 if len(lst) == 0
    return None  # 或进行特殊处理

# 索引越界检查
if i < 0 or i >= len(lst):
    raise IndexError("Index out of range")

# 单个元素情况
if len(lst) == 1:
    # 特殊处理
顺序表基础操作实现：
class SequentialList:
    def __init__(self):
        self.data = []  # 用Python列表作为底层存储
    
    def is_empty(self):
        """判断顺序表是否为空"""
        return len(self.data) == 0
    
    def length(self):
        """返回顺序表长度"""
        return len(self.data)
    
    def get_element(self, index):
        """获取指定位置的元素"""
        if index < 0 or index >= len(self.data):
            raise IndexError("索引越界")
        return self.data[index]
    
    def locate_element(self, value):
        """查找元素位置"""
        for i in range(len(self.data)):
            if self.data[i] == value:
                return i
        return -1
    
    def insert_element(self, index, value):
        """在指定位置插入元素"""
        if index < 0 or index > len(self.data):
            raise IndexError("插入位置不合法")
        self.data.insert(index, value)
    
    def delete_element(self, index):
        """删除指定位置元素"""
        if index < 0 or index >= len(self.data):
            raise IndexError("删除位置不合法")
        return self.data.pop(index)
    
    def display(self):
        """显示顺序表内容"""
        print("顺序表内容:", self.data)
    
    def clear(self):
        """清空顺序表"""
        self.data = []

# 测试代码
if __name__ == "__main__":
    seq_list = SequentialList()
    
    # 插入元素
    seq_list.insert_element(0, 10)
    seq_list.insert_element(1, 20)
    seq_list.insert_element(2, 30)
    seq_list.insert_element(1, 15)  # 在位置1插入15
    
    seq_list.display()  # 输出: 顺序表内容: [10, 15, 20, 30]
    
    # 访问元素
    print("位置2的元素:", seq_list.get_element(2))  # 输出: 20
    
    # 查找元素
    print("元素15的位置:", seq_list.locate_element(15))  # 输出: 1
    
    # 删除元素
    seq_list.delete_element(1)
    seq_list.display()  # 输出: 顺序表内容: [10, 20, 30]
顺序表高级操作实现：
def reverse_list(lst):
    """反转顺序表"""
    left, right = 0, len(lst) - 1
    while left < right:
        lst[left], lst[right] = lst[right], lst[left]
        left += 1
        right -= 1

def remove_duplicates(lst):
    """删除顺序表中的重复元素（原地修改）"""
    if not lst:
        return 0
    
    i = 0
    for j in range(1, len(lst)):
        if lst[j] != lst[i]:
            i += 1
            lst[i] = lst[j]
    
    # 截断列表
    while len(lst) > i + 1:
        lst.pop()
    
    return i + 1

def merge_sorted_lists(lst1, lst2):
    """合并两个有序顺序表"""
    result = []
    i, j = 0, 0
    
    while i < len(lst1) and j < len(lst2):
        if lst1[i] <= lst2[j]:
            result.append(lst1[i])
            i += 1
        else:
            result.append(lst2[j])
            j += 1
    
    # 添加剩余元素
    result.extend(lst1[i:])
    result.extend(lst2[j:])
    
    return result
练习题
题目1：顺序表基本操作
实现一个顺序表类，要求包含以下方法：
insert(index, value): 在指定位置插入元素
delete(index): 删除指定位置元素
search(value): 查找元素返回位置
update(index, value): 修改指定位置元素
get_size(): 返回当前元素个数
要求：处理好边界情况（空表、索引越界等）
class SequentialList:
    def __init__(self):
        self.data = []
    
    def insert(self, index, value):
        if index < 0 or index > len(self.data):
            raise IndexError("插入位置不合法")
        self.data.insert(index, value)
    
    def delete(self, index):
        if self.is_empty():
            raise Exception("顺序表为空")
        if index < 0 or index >= len(self.data):
            raise IndexError("删除位置不合法")
        return self.data.pop(index)
    
    def search(self, value):
        for i in range(len(self.data)):
            if self.data[i] == value:
                return i
        return -1
    
    def update(self, index, value):
        if index < 0 or index >= len(self.data):
            raise IndexError("修改位置不合法")
        old_value = self.data[index]
        self.data[index] = value
        return old_value
    
    def get_size(self):
        return len(self.data)
    
    def is_empty(self):
        return len(self.data) == 0
    
    def display(self):
        print(self.data)

题目2：顺序表去重
编写函数 remove_duplicates(lst)，删除顺序表中所有重复的元素，只保留每个元素的第一次出现。
示例：
输入: [1, 2, 2, 3, 4, 4, 5]
输出: [1, 2, 3, 4, 5]
要求：尽量使用原地算法，空间复杂度O(1)
def remove_duplicates(lst):
    if not lst:
        return 0
    
    # 使用双指针法
    i = 0
    for j in range(1, len(lst)):
        if lst[j] != lst[i]:
            i += 1
            lst[i] = lst[j]
    
    # 截断列表
    while len(lst) > i + 1:
        lst.pop()
    
    return i + 1

# 测试
test_list = [1, 2, 2, 3, 4, 4, 5]
new_length = remove_duplicates(test_list)
print(test_list[:new_length])  # 输出: [1, 2, 3, 4, 5]

题目3：合并有序顺序表
编写函数 merge_sorted_lists(lst1, lst2)，将两个升序排列的顺序表合并成一个新的升序顺序表。
示例：
输入: [1, 3, 5], [2, 4, 6]
输出: [1, 2, 3, 4, 5, 6]
要求：时间复杂度O(m+n)，其中m和n分别是两个列表的长度
def merge_sorted_lists(lst1, lst2):
    result = []
    i, j = 0, 0
    
    # 合并两个列表
    while i < len(lst1) and j < len(lst2):
        if lst1[i] <= lst2[j]:
            result.append(lst1[i])
            i += 1
        else:
            result.append(lst2[j])
            j += 1
    
    # 添加剩余元素
    result.extend(lst1[i:])
    result.extend(lst2[j:])
    
    return result

# 测试
list1 = [1, 3, 5]
list2 = [2, 4, 6]
merged = merge_sorted_lists(list1, list2)
print(merged)  # 输出: [1, 2, 3, 4, 5, 6]
